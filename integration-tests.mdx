---
title: Integration Tests
description: Integration tests for Chalk resolvers
---

import { PyEditor } from '@/components/Editor'
import { highlightedCode as integrationTest } from '@/samples/features/integration_test.py?highlight=py'

---

In the previous section, we talked about how to [unit-test individual resolvers](/docs/unit-tests)—this process is easy since each resolver is a callable Python functions and you can assert on the expected output. In this section we will talk about writing integration tests. Chalk provides two features that make integration testing really easy:
- branch deployments,
- The `check` method of the python Chalk client.

With branch deploys, you can deploy and test your changes in an isolated environment before
shipping your code into production.

With Chalk `check`, you can set up simple integration tests that assert on the expected outputs of your queries.

---

## Branch deployments

Chalk allows you to create an unlimited number of branch deployments.
Branch deployments run all of your resolvers in the same way
that they run in production. However, branch deployments don't impact
the [offline store](/docs/query-offline).

### Creating a branch deployment

You can create a branch deployment in the same
way that you create a full deployment by passing
the flag [`--branch <branch_name>`](/cli/apply).

```bash
# --branch creates a branch deployment
> chalk apply --force --await --branch <branch_name>
```

The [`--await`](/cli/apply#await) flag means that the deployment will
be live by the time that the command returns.

### Querying a branch deployment

You can quickly check your branch deployment using
[`chalk query --branch`](/cli/query) on the command line to
pull feature values:

```bash
# Example of making a query directly
> chalk query --branch <branch_name> \
              --in user.id=1 \
              --out user.id \
              --out user.email
```

The flag [`--branch`](/cli/query) tells this query to target the branch set during `chalk apply`.

Branch deployments are a great way to quickly test whether the changes you have made to features
or resolvers are behaving as expected when they are composed and executed in response to Chalk
queries.

However, if you want to write conrete integration tests, we recommend using the `check` method of
the Chalk python client.

---

## Writing Integration Tests

Suppose you have the following features defined in chalk:

```python
from chalk.features import DataFrame, features, FeatureTime

@features
def Transaction:
    id: int
    user_id: "User.id"
    amount: float
    ts: FeatureTime

@features
def User:
    id: int
    transactions: DataFrame[Transaction]
    transaction_count: Windowed[int] =  windowed(
        "1d", "3d"
        expression=_.transactions[_.ts > _.chalk_window].count(),
    )
    transaction_mean: Windowed[float] =  windowed(
        "1d", "3d"
        expression=_.transactions[_.ts > _.chalk_window].mean(),
    )
```

You can write integration tests with the `ChalkClient` by leveraging the `check` method. The `check` method allows assertion on values, errors, and cache hits. Mismatches between expected
and resolved data will be printed in a table.

```python
from chalk.client import ChalkClient
from chalk.features import DataFrame
from src.feature_sets import Transaction, User
import datetime as dt
import pytest

client = ChalkClient()

@pytest.fixture()
def client():
    return ChalkClient(local=True)
    # return ChalkClient(branch=True) # Uses your current git branch


def test_transaction_aggregations():
    now = dt.now()

    result = client.check(
        input={
            User.id: 1,
            User.transactions: DataFrame([
                Transaction(id=1, amount=10, ts=now - dt.timedelta(days=1)),
                Transaction(id=2, amount=20, ts=now - dt.timedelta(days=2)),
                Transaction(id=3, amount=30, ts=now - dt.timedelta(days=3)),
                Transaction(id=4, amount=40, ts=now - dt.timedelta(days=4)),
                Transaction(id=5, amount=50, ts=now - dt.timedelta(days=5)),
                Transaction(id=6, amount=60, ts=now - dt.timedelta(days=6)),
                Transaction(id=7, amount=70, ts=now - dt.timedelta(days=7)),
                Transaction(id=8, amount=80, ts=now - dt.timedelta(days=8)),
                Transaction(id=9, amount=90, ts=now - dt.timedelta(days=9)),
            ])
        },
        assertions={
            User.transaction_sum["3d"]: 60,
            User.transaction_sum["1d"]: 10,
            User.transaction_mean["1d"]: 10,
            User.transaction_mean["3d"]: 21,    # oops, this is wrong
        }
    )
```

if you run `pytest -s tests/test_transaction_aggregations.py`, you will get the following output:

Note, since the user's transactions are explicitly passed—they will not be fetched from any online resolver
you've defined to pull transactions (for example from a database).

---

## Writing Integration Tests

Mocking Inputs Using Tagged Resolvers

---

## Integration test

You can also target a branch from the
[Chalk API client](/docs/query-basics).
Using this client, you can write integration tests:

<PyEditor html={integrationTest} filename={'integration_test.py'} />

---

## GitHub Action

Chalk can be easily integrated in a
[GitHub Action](https://github.com/chalk-ai/cli-action).
You will need to create a Chalk token from the settings
page of your dashboard and store the resulting client
id and secret as
[GitHub Secrets](https://docs.github.com/en/actions/security-guides/encrypted-secrets#creating-encrypted-secrets-for-a-repository).

```yaml
name: Chalk Integration Test

on: push

jobs:
  chalk-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies
        run: pip install -r requirements.txt

      - uses: chalk-ai/deploy-action@v2
        with:
          client-id: ${{secrets.CHALK_CLIENT_ID}}
          client-secret: ${{secrets.CHALK_CLIENT_SECRET}}
          # Deploys Chalk to a branch environment
          branch: ${{ GITHUB_REF_NAME }}
          # Waits for the deployment to succeed (Optional, default false)
          await: true

      - name: Runs a test query against the branch
        run: |
          # Example of making a query directly against a branch
          chalk query --branch ${{ GITHUB_REF_NAME }} \
                      --in user.id=1 \
                      --out user.id \
                      --out user.email \
                      --json \
                      --include-meta

          # Alternatively, run the integration test suite, which should make queries with the branch parameter.
          pytest -s ./tests
```
