---
title: Has Many
description: Define one-to-many and many-to-many relationships between feature classes.
---

import { PyDiffEditor } from '@/components/Editor'
import { highlightedCode as manyToOneDiff } from '@/samples/features/many_to_one.py?highlight=diff-py'
import { highlightedCode as oneToManyDiff } from '@/samples/features/one_to_many.py?highlight=diff-py'
import { highlightedCode as manyToManyDiff } from '@/samples/features/many_to_many.py?highlight=diff-py'
import { TipInfo } from '@/components/Tip'

---

Has-many relationships link a feature to many instances of another feature.

## Recommended Implementation

The recommended way to specify a join for a has-many relationship is implicitly. In the
example below, a `User` is linked to potentially multiple `Transfer`s.

```py
from chalk.features import features, DataFrame, ...

@features
class Transfer:
    id: str
    # note, the annotation must be a string reference because User is
    # defined after Transfer.
    user_id: "User.id"
    amount: float

@features
class User:
    id: str
    transfers: DataFrame[Transfer]
```

## Explicit Join

The following example, which explicitly sets the join, is equivalent to the above:

```py
from chalk.features import has_many, DataFrame

@features
class Transfer:
    id: str
    user_id: str
    amount: float

@features
class User:
    id: str
    transfers: DataFrame[Transfer] = has_many(lambda: Transfer.user_id == User.id)
```

## Aggregations on References

Having established a has-many relationship, you can now reference the transfers for
a user through the user namespace. The `has_many` feature returns a [chalk.DataFrame](/docs/dataframe),
which supports many helpful aggregation operations:

```py
# Number of transfers made by a user
User.transfers.count()

# Total amount of transfers made by the user
User.transfers[Transfer.amount].sum()

# Total amount of the transfers made by the user that were returned
User.transfers[
    Transfer.status == "returned",
    Transfer.amount
].sum()
```

---

## Back-references

### One-to-many

In the reverse direction, a one-to-many relation is defined by a [has_one](/docs/has-one)
relation (following the above example, a user has many transfers but a transfer has a
single user). However, you don't have to explicitly set the join a second time. Instead,
the join condition is assumed to be symmetric and copied over. To complete the one-to-many
relationship from our example, add a `User` to the `Transfer` class:

<PyDiffEditor html={manyToOneDiff} />

<TipInfo>Here, you need to use quotes around `User` to use a forward reference.</TipInfo>

[//]: # (Alternatively, you could define the join condition on the same)

[//]: # (side, and add the [DataFrame]&#40;/docs/dataframe&#41; to the `User` class:)

[//]: # ()
[//]: # (<PyDiffEditor html={oneToManyDiff} />)

[//]: # (<TipInfo>Again, you need to use quotes around `User` deal with forward references.</TipInfo>)

### Many-to-many

The recommended way to define a many-to-many relationship is through a joining feature class.
For instance, if you were defining a many-many relationship between `Actors` and `Movies`, you
would define something like:

```python
from chalk.features import features, DataFrame
from chalk import online

@features
class Actor:
  id: str
  appearances: "DataFrame[ActorInMovie]"
  full_name: str
  movie_ids: list[int]

@features
class Movie:
  id: str
  title: str
  cast: list[ids]

@features
class ActorInMovie:
  id: str
  actor_id: Actor.id
  movie_id: Movie.id
  movie: Movie
```

<TipInfo>
  Here you need to use quotes around `DataFrame[ActorInMovie]` to use a forward reference.
</TipInfo>

This joining feature class can either by populated by:

A SQL Resolver
```sql
-- resolves: ActorInMovie
SELECT a.id||'_'||m.id as id, a.id as actor_id, m.id as movie_id FROM actors a CROSS JOIN movies m;
```

or, by a `DataFrame` returning python resolver (namespaced to one of the joined feature sets):

```python
@online
def get_actor_in_movie(a_id: Actor.id, movie_ids: Actor.movie_ids) -> Actor.appearances:
  return DataFrame([
    ActorInMovie(id=f"{a_id}_{m_id}", actor_id=a_id, movie_id=m_id)
    for m_id in movie_ids
  ])

```

With the above in place, you can now query for movie features from the actor namespace. For example, if you wanted to
query for the names of all the movies an actor appears in, you can do this using a

```sh
chalk query --in actor.id=1 --out actor.appearances.movie.title
```
