---
title: Underscore
description: Using underscore expressions to define features
---

---

## Overview

Underscore expressions are used to derive features from operations on other features. In feature definitions, `_`
represents a reference to the containing feature class and is used to access other features in the same instance. In
addition to arithmetic operations, underscore expressions can also be used to filter and aggregate data.

Underscore expressions are useful because Chalk statically analyzes and optimizes them, leading to better performance
when compared to equivalent Python resolvers. They are also useful for succinctly defining common features, such as the
number of times a user failed a login attempt over the past 30 days or the total amount spent at a given merchant.

## Arithmetic

In this example, we have a Transaction feature class with `total` and `sales_tax` features and we want to define
`subtotal` as `total` minus `sales_tax`. Instead of writing a Python resolver, we can resolve `subtotal` with an
underscore expression:

```diff-py
- from chalk import online
+ from chalk.features import _, features

@features
class Transaction:
    id: int
    total: float
    sales_tax: float
+   subtotal: float = _.total - _.sales_tax

- @online
- def get_subtotal(total: Transaction.total, sales_tax: Transaction.sales_tax) -> Transaction.subtotal:
-     return total - sales_tax
```

## Conditions and filters

DataFrame features can be [filtered](/docs/dataframe#filters) with underscore expressions.

Extending our `Transaction` example, we can create `User` feature class with a [has-many](/docs/has-many) relationship
to `Transaction`. Then, we can define a feature representing large purchases by referencing the existing
`User.transactions` feature:

```diff-py
from chalk.features import _, features, DataFrame

@features
class Transaction:
    id: int
+   user_id: "User.id"
    total: float
    sales_tax: float
    subtotal: float = _.total - _.sales_tax

+ @features
+ class User:
+    id: int
+    # implicit has-many relationship with Transaction due to `user_id` above
+    transactions: DataFrame[Transaction]
+    large_transactions: DataFrame[Transaction] = _.transactions[_.total > 1000]
```

The object referenced by `_` changes depending on its current scope. In this code, the `_` in `_.transactions`
references the `User` object. Within the DataFrame filter, the `_` in `_.total` references each `Transaction` object as
each one is evaluated.

## Projections and aggregations

DataFrame features support [projection](/docs/dataframe#projections) with underscore expressions, which produce a new
DataFrame scoped down to the referenced columns. DataFrames can be aggregated after eligible columns are selected.

With our `Transaction` example, we can compute the number of large transactions a user as had as well as their total
spending volume:

```diff-py
from chalk.features import _, features, DataFrame

@features
class Transaction:
    id: int
    user_id: "User.id"
    total: float
    sales_tax: float
    subtotal: float = _.total - _.sales_tax

@features
class User:
    id: int
    # implicit has-many relationship with Transaction due to `user_id` above
    transactions: DataFrame[Transaction]
    large_transactions: DataFrame[Transaction] = _.transactions[_.total > 1000]
+   total_spend: float = _.transactions[_.total].sum()
+   num_large_transactions: int = _.large_transactions.count()
```

To compute `User.total_spend`, we needed to create a projection of the `User.transactions` DataFrame limited to only the
`Transaction.total` column so that the `sum` aggregation could work. In contrast, no projection was needed for
`num_large_transaction`'s `count` aggregation because `count` works on DataFrames with any number of columns.

## All supported operations

### Arithmetic
* Addition: `+`
* Subtraction: `-`
* Multiplication: `*`
* Division: `/`

### Conditions
* Greater than: `>`
* Greater than or equal: `>=`
* Less than: `<`
* Less than or equal: `<=`
* Equal: `==` [^1]
* Not equal: `!=` [^1]
* Boolean and: `&` [^1]
* Boolean or: `|` [^1]

### Aggregations
* `sum`
* `min`
* `max`
* `mean`
* `count`
* `any`
* `all`
* `std` (aliases: `stddev`, `stddev_sample`, `std_sample`)
* `var` (alias: `var_sample`)
* `approx_count_distinct`
* `count_distinct`
* `approx_percentile`

### Additional functions
The `chalk.functions` module exposes several helpful functions that can be used in
combination with underscore references to transform features:

* [`bytes_to_string`](/api-docs#bytes_to_string)
* [`coalesce`](/api-docs#coalesce)
* [`gunzip`](/api-docs#gunzip)
* [`json_value`](/api-docs#json_value)
* [`md5`](/api-docs#md5)
* [`string_to_bytes`](/api-docs#string_to_bytes)

[^1]: Be careful to not use Python's `and`, `or`, `not`, or `is` operators. Python does not allow these operators to be
overridden. They take precedence and will be evaluated with native Python, so they will not work with Chalk's underscore
expressions.
