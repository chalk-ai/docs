---
title: Snapshot Tests
description: Snapshot testing with Chalk
---

Snapshot testing is an effective way of ensuring that your features are not dramatically changing
between deployments. You can set up snashot testing in Chalk by leveraging Chalk [Datasets].

Typically, snapshot testing will be part of a CI (continuous integration) workflow. Pull requests will automatically
trigger tests which verify that code changes have not caused feature distributions shifts.

In this section, we'll demonstrate the process of writing snashot tests using pytest and Github Actions.

## Overview

To set up snapshot testing, we'll write a couple pytest fixtures and a test. The fixtures will pull your current
snaphot data and create a new snapshot based on your current code. The test will then compare the distributions of
the features in your old and new datasets.

In this example we'll be snapshot testing the features on the following feature class:

```python
from chalk.features import features
import datetime as dt

@features
class User:
    id: int
    full_name: name
    birthday: dt.datetime
    age: float
```

In this example, we resolve the `full_name` and birthday of our User's from from a Postgres database. The age feature is calculated using an online resolver:
```python
from chalk import online
from chalk.features import Now

@online
def birthday_resolver(bday: User.birthday, now: Now) -> User.age:
    return now.year - bday.year - ((now.month, now.day) < (bday.month, bday.day))
```

Though this is a rather trivial example, lets set some expectations for our feature distribution shifts between snapshots:
- We expect a User's birthday to never change,
- We expect a User's full_name to change in a maximum of 0.001% of our users (1/100,000),
- We expect a User's age to change by a maximum amount of 30 days (in reality, average age will increase by precisely the amount of time between invocations of our snapshot test).

## Writing the Test

First we'll write two fixtures: the first sets up a Chalk Client and the second creates your new snapshot (using
the previous snaphot to make sure that the exact same ids are being pulled).

```
from chalk.client import ChalkClient
from chalk.features import DataFrame
from src.feature_sets import Transaction, User
import datetime as dt
import pytest
import pandas as pd


@pytest.fixture(scope="session")
def client():
    return ChalkClient(branch=True) # Uses your current git branch


@pytest.fixture(scope="session")
def snapshots(client: ChalkClient):
    # The dataset name will be set to the latest commit on the branch
    branch_commit = os.environ["GITHUB_SHA"]

    # The snapshot will find the dataset with the
    latest_commit = os.environ["GITHUB_HEAD_REF"]

    main_snapshot = client.get_dataset(dataset_name=latest_commit)
    main_snapshot_df = snapshot.to_pandas()

    branch_snapshot = client.offline_query(
        input=active_snapshot[User.id].to_list(),
        wait=True,
        dataset_name=branch_commit
    )
    branch_snapshot_df = branch_snapshot.to_pandas()

    return active_snapshot_df, branch_snapshot_df

def test_transaction_aggregations(snaphot_dfs: tuple[pd.DataFrame, pd.DataFrame]):
    main_snapshot, branch_snapshot = snapshot_dfs

    compare_snapshots(main_snapshot, branch_snapshot)
```

## Writing the Github Action

The Gihub Action, sets up the environment and then runs pytest. Because the
Github Action is set to run on `pull`, we have access to not only the
active commit (in the environment variable `GITHUB_SHA`), but also the
target commit of the pull request (`GITHUB_HEAD_REF`).

```yaml
name: Chalk Integration Test

on: pull

jobs:
  chalk-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies
        run: pip install -r requirements.txt

      - uses: chalk-ai/deploy-action@v2
        with:
          client-id: ${{secrets.CHALK_CLIENT_ID}}
          client-secret: ${{secrets.CHALK_CLIENT_SECRET}}
          # Deploys Chalk to a branch environment
          branch: ${{ GITHUB_REF_NAME }}
          # Waits for the deployment to succeed (Optional, default false)
          await: true

      - name: Runs the Snaphot Test
        run: |
          # Example of making a query directly against a branch
          pytest -s ./tests
```

## Bootstrapping the Github Action

Before this works fully, we will need to bootstrap the snapshot test. If you tried
to run the action above, you'd get an error calling `client.get_dataset()`, which
would indicate that the dataset was not found. To bootstrap the snaphots, you'll
want to run an `offline_query` to create a named dataset with the current `HEAD`
commit of your github repository.

To get the latest commit in your repo, you can run
```sh
$ git checkout main > /dev/null; git rev-parse @
```

in your terminal. This should give you a commit that looks something like: `9e0399983458045bedcfa413d7a37fd89a419bd1`.

You can now run an offline query using the python client to create the first snapshot:
```python
from src.feature_sets import User

client.offline_query(
    output=[User],
     # This can be however many you want to include in your snapshot
    max_samples=50_000,
    dataset_name="9e0399983458045bedcfa413d7a37fd89a419bd1"
)
```

With your initial shapshot created, future pull requests will be able to automatically execute a snapshot test
against your main deployment.
