---
title: Chalk Clients
description: Fetch feature values via online query.
published: true
llms: short
---

import {ClientLibraries} from "@/components/HighlightsGrid";
import { RequestingFeaturesOnline } from '@/components/home/RequestingFeaturesOnline'
import {
  Attribute,
  AttributeTable,
  SubAttribute,
  SubAttributeTable,
} from '@/components/AttributeTable'
import { RequestUrl } from '@/components/RequestUrl'

---

Chalk maintains several client libraries (gRPC) and a REST API for fetching feature values.

---

## Library support

Chalk maintains libraries in several major languages
for fetching online feature values. If you need support
for a language that we don't support, let us know!
We also support a rest API if you'd like to build your
own.


<ClientLibraries />

<RequestingFeaturesOnline />

---

## REST API

Chalk supports a REST API for querying online features
and exposes this endpoint in several API clients.
When you execute an online query, [resolvers](/docs/resolver-online-offline)
will execute to produce the requested data.
Online query will prioritize running online resolvers over offline resolvers to compute features
if both are possible.

The following endpoint can also be hit with the python [ChalkClient](/api-docs#ChalkClient) by using its `query` method.
For information on how to authenticate the `ChalkClient`, check out the section on
[authentication](/docs/online-authentication).
Read more about the parameters to this method [here](/api-docs#ChalkClient.query).


---

## Request

<RequestUrl url="https://api.chalk.ai/v1/query/online" type="POST" />

<AttributeTable>

<Attribute field={'inputs'} kind={'map[string, JSON]'}>
  Input features and values are provided at the time of request.
  For example, primary key-value pairs often designate the subset of data returned. Feature inputs
  are provided by fully qualified path.  <a href={'/docs/has-many'}>Has many features</a>
  are input as lists, and <a href={'/docs/feature-types#dataclass'}>struct features</a> are input as JSON.

  An example of passing a user with two credit cards as input:
  <code>{"{user.id: '1', user.cards: [Card(id='xyz'), Card(id='abc')]}"}</code>
</Attribute>

<Attribute field={'outputs'} kind={'string[]'}>
  Outputs are the features that you'd like to compute from the inputs.
</Attribute>

<Attribute
  field={'staleness'}
  kind={
    <span>
      map[string, <a href={'/docs/duration'}>duration</a>]
    </span>
  }
>
  Maximum staleness overrides for any output features or intermediate features. See{' '}
  <a href={'/docs/query-caching'}>query caching</a> for more information.
</Attribute>

<Attribute field={"context"} kind={"QueryContext?"}>
The context object controls the environment and tags
under which a request should execute resolvers:

<SubAttributeTable title={"QueryContext"}>

<SubAttribute field={'environment'} kind={'string?'}>
The <a href={'/docs/resolver-environments'}>environment</a> in which to run the resolvers.
Like resolvers, API tokens can be scoped to an environment.
If no environment is specified in the query,
but the token supports only a single environment,
then that environment will be taken as the scope for executing
the request.

</SubAttribute>

<SubAttribute field={'tags'} kind={'string[]?'}>
  The <a href={'/docs/resolver-tags'}>tags</a> used to scope the resolvers.
</SubAttribute>

</SubAttributeTable>

</Attribute>

<Attribute field={'preview_deployment_id'} kind={'string?'}>
  The preview deployment id. See{' '}
  <a href={'/docs/integration-tests#branch-deployments'}>Preview Deployments</a> for more
  information.
</Attribute>

<Attribute field={'query_name'} kind={'string?'}>
  The query name. See <a href={'/api-docs#NamedQuery'}>NamedQuery</a> for more details.
</Attribute>

<Attribute field={'branch'} kind={'string?'}>
  If specified, routes to the relevant branch. See{' '}
  <a href={'/docs/branches'}>Branches</a> for more
  information.
</Attribute>

</AttributeTable>

More information on parameters is available [here](/api-docs#ChalkClient.query)

---

## Response

<AttributeTable>
<Attribute field={'data'} kind={<a href={'#query-basics'}>FeatureResult[]</a>}>
The outputs features and any query metadata
<SubAttributeTable title={"FeatureResult"}>

<SubAttribute field={'field'} kind={'string'}>
  The name of the feature requested, eg.{' '}
  <code className={'whitespace-nowrap before:content-none dark:text-white after:content-none'}>
    user.identity.has_voip_phone
  </code>
  .
</SubAttribute>

<SubAttribute field={'value'} kind={'typeof(field)?'}>
  The value of the requested feature. If an error was encountered in resolving this feature, this
  field will be empty.
</SubAttribute>

<SubAttribute field={'error'} kind={<a href={'/docs/query-errors#error-code'}>ChalkError?</a>}>
  The error code encountered in resolving this feature. If no error occurred, this field is empty.
</SubAttribute>

<SubAttribute field={'meta'} kind={'FeatureResolutionMeta?'}>
  Metadata pertaining to the feature, including the resolver run and whether the result was a cache hit.
</SubAttribute>

</SubAttributeTable>

</Attribute>

<Attribute field={'errors'} kind={<a href={'query-errors#chalk-error'}>ChalkError[]?</a>}>
Errors encountered while running the resolvers. Each element in the list is a{' '}
<a href={'query-errors#chalk-error'}>ChalkError</a>. If no errors were encountered, this field
is empty.
</Attribute>

<Attribute field={'meta'} kind={'QueryMeta?'}>
Metadata related to the query. Returned if {' '}
<code className={'whitespace-nowrap before:content-none dark:text-white after:content-none'}>
    include_meta
</code> or {' '}
<code className={'whitespace-nowrap before:content-none dark:text-white after:content-none'}>
    explain
</code> is set to {' '}
<code className={'whitespace-nowrap before:content-none dark:text-white after:content-none'}>
    True
</code>.


<SubAttributeTable title={"QueryMeta"}>

<SubAttribute field={'execution_duration_s'} kind={'float'}>
The time, expressed in seconds, that Chalk spent executing this query.
</SubAttribute>

<SubAttribute field={'deployment_id'} kind={'string?'}>
The id of the deployment that served this query.
</SubAttribute>

<SubAttribute field={'environment_id'} kind={'string?'}>
The id of the environment that served this query.
</SubAttribute>

<SubAttribute field={'environment_name'} kind={'string?'}>
The short name of the environment that served this query. For example: "dev" or "prod".
</SubAttribute>

<SubAttribute field={'query_id'} kind={'string?'}>
A unique ID generated and persisted by Chalk for this query. All computed features, metrics, and logs are
associated with this ID. Your system can store this ID for audit and debugging workflows.
</SubAttribute>

<SubAttribute field={'query_timestamp'} kind={'datetime?'}>
At the start of query execution, Chalk computes 'datetime.now()'.
This value is used to timestamp computed features.
</SubAttribute>

<SubAttribute field={'query_hash'} kind={'string?'}>
Deterministic hash of the 'structure' of the query. Queries that have the same input/output features will
typically have the same hash; changes may be observed over time as we adjust implementation details.
</SubAttribute>

<SubAttribute field={'explain_output'} kind={'string?'}>
An unstructured string containing diagnostic information about the query execution.
Only included if
<code className={'whitespace-nowrap before:content-none dark:text-white after:content-none'}>
explain
</code> is set to
<code className={'whitespace-nowrap before:content-none dark:text-white after:content-none'}>
True
</code>.
</SubAttribute>

</SubAttributeTable>

</Attribute>
</AttributeTable>

---

## Query Explanation

Chalk offers support for the user for when queries don't work.
The first step is always to check to see the response contains any `errors`.
Often, the error message will directly point to the failure.

In the case of more complicated queries, queries can be sent with `explain=True`.
This will return a representation of the query plan in the `meta` return attribute.
The user can use this information to verify the resolvers and operators ran during execution.
Beware, this will result in slower execution times.

Some queries that involve multiple operations might need additional tracking.
Users can supply `store_plan_stages=True` to store intermediate outputs at all operations of the query.
This will dramatically slow things down, so use wisely!
These results are visible in the dashboard under the "Queries" page.

For more information, read the `ChalkClient` docs [here](/api-docs#ChalkClient.query).

---

## Online Query Bulk

Compute feature values for many rows of inputs using online resolvers. This endpoint is similar to the
online query endpoint, but takes in lists of inputs and produces one output per row of inputs.
This is appropriate when you want to fetch the same set of features for many different input primary keys.

The following endpoint can be accessed with the Python [ChalkClient](/api-docs#ChalkClient) by using its `query_bulk` method.

### Request

<RequestUrl url="https://api.chalk.ai/v1/query/feather" type="POST" />

The request body should be a binary payload containing:
1. A magic string identifier
2. Serialized query metadata
3. Feature data in Apache Feather format

When using the ChalkClient, this serialization is handled automatically. For direct HTTP usage, the structure is:
- Request inputs are provided as mappings of feature names to **lists** of values
- Each list should have the same length, representing multiple rows of data

<AttributeTable>

<Attribute field={'inputs'} kind={'map[string, JSON[]]'}>
  Input features and **lists** of values. Each key is a feature name (e.g., `"user.id"`) and
  each value is a list of values for that feature. All lists must have the same length, where
  each element represents one row.

  <a href={'/docs/has-many'}>Has-many features</a> are input as lists within each row element,
  and <a href={'/docs/feature-types#dataclass'}>struct features</a> (has-one) are input as JSON objects within each row element.

  Example with simple, has-one, and has-many features:
  ```json
  {
    "user.id": [1, 2],
    "user.name": ["Alice", "Bob"],
    "user.profile": [
      {"age": 30, "city": "NYC"},
      {"age": 25, "city": "SF"}
    ],
    "user.cards": [
      [{"id": "card1"}, {"id": "card2"}],
      [{"id": "card3"}]
    ]
  }
  ```
</Attribute>

<Attribute field={'outputs'} kind={'string[]'}>
  The features that you'd like to compute from the inputs. Same as online query.
</Attribute>

<Attribute field={'now'} kind={'string[]?'}>
  List of timestamps (ISO format) for each row. If provided, the list must match the length
  of the input value lists. Each timestamp represents the query time for the corresponding row.
</Attribute>

<Attribute field={'staleness'} kind={
  <span>
    map[string, <a href={'/docs/duration'}>duration</a>]
  </span>
}>
  Maximum staleness overrides for any output features or intermediate features.
  See <a href={'/docs/query-caching'}>query caching</a> for more information.
</Attribute>

<Attribute field={"context"} kind={"QueryContext?"}>
The context object controls the environment and tags under which requests execute:

<SubAttributeTable title={"QueryContext"}>

<SubAttribute field={'environment'} kind={'string?'}>
The <a href={'/docs/resolver-environments'}>environment</a> in which to run the resolvers.
</SubAttribute>

<SubAttribute field={'tags'} kind={'string[]?'}>
The <a href={'/docs/resolver-tags'}>tags</a> used to scope the resolvers.
</SubAttribute>

<SubAttribute field={'required_resolver_tags'} kind={'string[]?'}>
If specified, all required_resolver_tags must be present on a resolver for it to be eligible to execute.
</SubAttribute>

</SubAttributeTable>

</Attribute>

<Attribute field={'query_name'} kind={'string?'}>
  The semantic name for the query, e.g., `"loan_application_model"`. See <a href={'/api-docs#NamedQuery'}>NamedQuery</a>.
</Attribute>

<Attribute field={'query_name_version'} kind={'string?'}>
  The version of the named query to execute.
</Attribute>

<Attribute field={'correlation_id'} kind={'string?'}>
  A globally unique ID for the query, used in logs and web interfaces.
</Attribute>

<Attribute field={'branch_id'} kind={'string?'}>
  If specified, routes to the relevant <a href={'/docs/branches'}>branch</a>.
</Attribute>

<Attribute field={'preview_deployment_id'} kind={'string?'}>
  If specified, routes to the relevant <a href={'/docs/integration-tests#branch-deployments'}>preview deployment</a>.
</Attribute>

<Attribute field={'explain'} kind={'bool?'}>
  If true, returns query execution plan in the response metadata. Makes the query slower.
</Attribute>

<Attribute field={'store_plan_stages'} kind={'bool?'}>
  If true, stores intermediate outputs at all query plan stages. Dramatically impacts performance.
</Attribute>

<Attribute field={'meta'} kind={'map[string, string]?'}>
  Arbitrary key-value pairs to associate with the query.
</Attribute>

<Attribute field={'query_context'} kind={'map[string, JSON] | string?'}>
  An immutable context accessible from Python resolvers. See <a href={'/api-docs#ChalkContext'}>ChalkContext</a>.
</Attribute>

</AttributeTable>

### Response

The response is a binary payload in Apache Feather format containing the results.

<AttributeTable>

<Attribute field={'results'} kind={'BulkOnlineQueryResult[]'}>
A list of query results, where each result contains:

<SubAttributeTable title={"BulkOnlineQueryResult"}>

<SubAttribute field={'scalars_df'} kind={'DataFrame?'}>
A DataFrame containing the scalar feature values for all rows. Each row corresponds to an input row.
Columns are feature names, and values are the computed feature values.
</SubAttribute>

<SubAttribute field={'groups_dfs'} kind={'map[string, DataFrame]?'}>
A map of feature names to DataFrames for has-many features.
</SubAttribute>

<SubAttribute field={'errors'} kind={<a href={'/docs/query-errors#chalk-error'}>ChalkError[]?</a>}>
Errors encountered while running the resolvers.
</SubAttribute>

<SubAttribute field={'meta'} kind={'QueryMeta?'}>
Metadata about query execution including execution duration, deployment ID, query ID, etc.
See the online query response documentation for QueryMeta details.
</SubAttribute>

</SubAttributeTable>

</Attribute>

</AttributeTable>

---

## Offline Query

Submit an offline query to compute feature values from the offline store or by running offline/online resolvers.
Offline queries are typically used for generating training datasets and run asynchronously.

The following endpoint can be accessed with the Python [ChalkClient](/api-docs#ChalkClient) by using its `offline_query` method.
See the [offline query documentation](/docs/query-offline) for more information.

### Request

<RequestUrl url="https://api.chalk.ai/v1/query/run" type="POST" />

The request body is a binary payload containing:
1. Serialized query plan (protobuf)
2. Query metadata (JSON)
3. Input data (Apache Feather format)

When using the ChalkClient, this serialization is handled automatically.

<AttributeTable>

<Attribute field={'input'} kind={'map[string, JSON[]] | DataFrame | URI'}>
  The features for which there are known values. Can be:
  - A mapping of feature names to lists of values (similar to bulk query format)
  - A DataFrame with input data
  - A URI pointing to input data in cloud storage

  When using a mapping, <a href={'/docs/has-many'}>has-many features</a> are input as lists within each row,
  and <a href={'/docs/feature-types#dataclass'}>struct features</a> (has-one) are input as JSON objects within each row.
  See the bulk query input format above for examples.
</Attribute>

<Attribute field={'input_times'} kind={'datetime[] | datetime?'}>
  Timestamps for point-in-time correctness. If a list, must match the length of input rows.
  See <a href={'/docs/temporal-consistency'}>temporal consistency</a>.
</Attribute>

<Attribute field={'output'} kind={'string[]'}>
  The features to compute or sample. If a feature was never computed for a sample, its value will be null.
</Attribute>

<Attribute field={'required_output'} kind={'string[]?'}>
  Features that must exist in each row. Rows where a required output was never stored will be skipped.
</Attribute>

<Attribute field={'recompute_features'} kind={'bool | string[]?'}>
  Controls whether resolvers run to compute features:
  - If `true`, all output features are recomputed by resolvers
  - If `false`, all output features are sampled from the offline store
  - If a list, features in the list are recomputed, others are sampled
</Attribute>

<Attribute field={'environment'} kind={'string?'}>
  The <a href={'/docs/resolver-environments'}>environment</a> in which to run resolvers.
</Attribute>

<Attribute field={'dataset_name'} kind={'string?'}>
  A unique name for the dataset. If provided, the dataset will be saved and can be retrieved later.
</Attribute>

<Attribute field={'max_samples'} kind={'int?'}>
  Maximum number of samples to include in the result. If not specified, all samples are returned.
</Attribute>

<Attribute field={'lower_bound'} kind={'datetime | duration | string?'}>
  Only query data observed after this timestamp. Accepts ISO 8601 format strings.
</Attribute>

<Attribute field={'upper_bound'} kind={'datetime | duration | string?'}>
  Only query data observed before this timestamp. Accepts ISO 8601 format strings.
</Attribute>

<Attribute field={'tags'} kind={'string[]?'}>
  The <a href={'/docs/resolver-tags'}>tags</a> used to scope the resolvers.
</Attribute>

<Attribute field={'branch_id'} kind={'string?'}>
  If specified, routes to the relevant <a href={'/docs/branches'}>branch</a>.
</Attribute>

<Attribute field={'correlation_id'} kind={'string?'}>
  A globally unique ID for the query, used in logs and web interfaces.
</Attribute>

<Attribute field={'query_name'} kind={'string?'}>
  The name of the query. If provided, creates a named query or fills in missing parameters from a preexisting execution.
</Attribute>

<Attribute field={'run_asynchronously'} kind={'bool?'}>
  If true, runs the query in separate Kubernetes pods. Useful for large datasets and long-running jobs.
</Attribute>

<Attribute field={'store_online'} kind={'bool?'}>
  If true, stores the query output in the online store.
</Attribute>

<Attribute field={'store_offline'} kind={'bool?'}>
  If true, stores the query output in the offline store.
</Attribute>

<Attribute field={'num_shards'} kind={'int?'}>
  If specified, splits the input across this many shards for parallel processing.
</Attribute>

<Attribute field={'resources'} kind={'ResourceRequests?'}>
  Override resource requests (CPU, memory) for the offline query job.
</Attribute>

</AttributeTable>

### Response

The response contains information about the submitted offline query job.

<AttributeTable>

<Attribute field={'job_id'} kind={'string'}>
  A unique identifier for the offline query job. Use this to check the job status.
</Attribute>

<Attribute field={'dataset_id'} kind={'string?'}>
  If a dataset_name was provided, this is the ID of the created dataset.
</Attribute>

</AttributeTable>

---

## Check Offline Query Status

Check the status of an offline query job. Offline queries run asynchronously, so you need to poll
this endpoint to determine when the job is complete and the results are ready.

### Request

<RequestUrl url="https://api.chalk.ai/v4/offline_query/status" type="POST" />

<AttributeTable>

<Attribute field={'job_id'} kind={'string?'}>
  The job ID returned from the offline query request (also called revision_id).
</Attribute>

<Attribute field={'dataset_name'} kind={'string?'}>
  The name of the dataset, if one was provided in the offline query request.
</Attribute>

<Attribute field={'dataset_id'} kind={'string?'}>
  The ID of the dataset.
</Attribute>

<Attribute field={'ignore_errors'} kind={'bool?'}>
  If true, returns results even if some errors occurred during execution. Default is false.
</Attribute>

<Attribute field={'skip_failed_shards'} kind={'bool?'}>
  If true, skips failed shards and returns results from successful shards only. Default is false.
</Attribute>

</AttributeTable>

You must provide at least one of: `job_id`, `dataset_name`, or `dataset_id`.

### Response

<AttributeTable>

<Attribute field={'is_finished'} kind={'bool'}>
  Whether the offline query job has completed. Poll this endpoint until this field is true.
</Attribute>

<Attribute field={'urls'} kind={'string[]'}>
  A list of short-lived, authenticated URLs to download the query results. These URLs point to
  data files in cloud storage (S3 or GCS) containing the feature values in a columnar format.
  Only populated when `is_finished` is true.
</Attribute>

<Attribute field={'errors'} kind={<a href={'/docs/query-errors#chalk-error'}>ChalkError[]?</a>}>
  Errors encountered during query execution, if any.
</Attribute>

<Attribute field={'version'} kind={'int'}>
  Version number representing the format of the data. The client uses this to properly decode
  and load the query results into DataFrames. Current version is 1.
</Attribute>

</AttributeTable>

Once `is_finished` is true, you can download the data from the provided URLs and load it into a DataFrame.
The ChalkClient's `Dataset` object handles this automatically.

---

